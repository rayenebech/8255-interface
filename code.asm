;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Cum Mar 11 2016
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;====================================================================
STAK    SEGMENT PARA STACK 'STACK'
        DW 20 DUP(?)
STAK    ENDS

DATA    SEGMENT PARA 'DATA'

unlocked  DB 0C1H  ; Shows the lette U on the 7seg
locked    DB 0C7H  ; Shows the lette L on the 7seg
errormsg  DB 86H   ; Shows the letter E on the 7seg
STATE	  DB 00H ; State of the system: 0 if unlocked, 1 if locked

;DIGITS	  DB 4FH, 7DH, 67H, 40H, 5BH, 6DH, 7FH, 3FH, 06H, 66H, 07H, 49H ; values of Common Cathode 7 seg 
NUMBERS	  DB 03H, 06H, 09H, 40H, 02H, 05H, 08H, 00H, 01H, 04H, 07H, 49H

HASH 	  DB 00H


MASTER 	  DB 00H, 01H, 00H, 00H   ; the master unlock key value
PASSWORD  DB 00H, 01H, 00H, 00H   ; the password that will be reset everytime , initilized to the master

TMP 	  DB 4 DUP(?) 
SAYI      DB 0H
IND 	  DW 0H
ATTEMPTS  DW 0H
EMPTY 	  DB 0H
DATA	ENDS

CODE    SEGMENT PARA 'CODE'
        ASSUME CS:CODE, DS:DATA, SS:STAK
START:
        MOV AX, DATA
	MOV DS, AX
	
        MOV AL, 81H ; 10000001 PORT C Low=1 and mod0=1
	OUT 0AEH, AL; Send 81H to the control word
	;reset the keypad
	MOV AL, 00H
	OUT 0AAH, AL
	
RESET:	;Make the system unlocked by default
	CALL UNLOCK7SEG
	MOV STATE , 0H
	MOV AL, 0F0H
	OUT 0ACH, AL ; reset the inputs of Port C low
MAINLOOP:
	 
	XOR DI,DI  			; DI is used to count up to 4 inputs
READ1:  MOV EMPTY, 0H	 
	CALL READ
	MOV AL, EMPTY			; control if the a button has been pressed
	CMP AL, 0H
	JE READ1			; we didn't read anything
	
	; a button has been pressed
	MOV SI , IND 			; fetch the index found by the read function
	MOV BL, NUMBERS[SI] 		; fetch the corresponding number
	MOV TMP[DI], BL			;save the number of the button to temporary password
	INC DI				; We completed input reading
	CMP DI, 4			; check if we finished reading everything
	JNE  READ1			; we read the remaining inputs
       
       ;all 4 inputs has been read 
	MOV BL, STATE			; check the current state of the 7seg (locked or unlocked currently)
	CMP BL, 0H			; check if the system is unlocked
	JZ UNLOCKED_LABEL		; 7seg is UNLOCKED
	
   	;7seg is LOCKED then check if the number of ATTEMPTS 
	MOV SI, ATTEMPTS			; fetch the total number of ATTEMPTS of password
	CMP SI, 4
	JAE MASTER_L
	CALL CHECK_PASSWORD
	;CALL WAIT_A_LITTLE ;spend some time
	JMP  MAINLOOP 
UNLOCKED_LABEL: 
READ2:	MOV EMPTY,0H
	CALL  READ ; wait for #
	MOV AL, EMPTY
	CMP AL, 0H
	JE READ2  ; we didn't read anything
	
	MOV BL, Hash ; the retrun value of read is in SAYI
	CMP BL, 0H ; comapare it with #
	JZ MAINLOOP ;RESET the system because we didn't get # after 4 inputs
	;else we lock and update the password 
	CALL UPDATE_PASSWORD
	;CALL WAIT_A_LITTLE ;spend some time
	JMP MAINLOOP ; we start over search,ng for new 4 inputs

MASTER_L: CALL CHECK_MASTER


	CALL WAIT_A_LITTLE ;spend some time
JMP MAINLOOP	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;Function to show L on the 7seg (Lock it)
LOCK7SEG PROC NEAR
   MOV AL, locked ;upload value to the 7seg
   OUT 0A8H, AL ;Output to Port A
   RET
LOCK7SEG ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Function to show U on the 7seg (Lock it)
UNLOCK7SEG PROC NEAR
   MOV AL, unlocked ;upload value to the 7seg
   OUT 0A8H, AL ;Output to Port A
   RET
UNLOCK7SEG ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Function to show e on the 7seg (Lock it)
ERROR PROC NEAR
   MOV AL, errormsg ;upload value to the 7seg
   OUT 0A8H, AL ;Output to Port A
   RET
ERROR ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Function to show e on the 7seg (Lock it)
UPDATE_PASSWORD PROC NEAR
      MOV CL, 4
      LEA BX, TMP
      LEA SI, PASSWORD
  L5: MOV CH,BYTE PTR[BX]
      MOV BYTE PTR[SI],CH
      ;MOV DH,BYTE PTR[SI]
      INC BX
      INC SI
      DEC CL
      CMP CL,0H
      JNZ L5

   CALL LOCK7SEG
   MOV STATE, 01H ; now the 7seg is locked so change the state
   MOV ATTEMPTS, 0H ; initialize the number of wrong attempts to 0
   RET
UPDATE_PASSWORD ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Function to check if the password is correct
CHECK_PASSWORD PROC NEAR
      ; compare the value of TMP with PASSWORD
      MOV CL, 4
      LEA BX, TMP
      LEA SI, PASSWORD
  L6: MOV CH,BYTE PTR[BX]
      CMP CH,BYTE PTR[SI]
      JNE FAIL1 ; if does not match
      ;MOV DH,BYTE PTR[SI]
      ;else move to next element 
      INC BX
      INC SI
      DEC CL
      CMP CL,0H
      JNZ L6
      
OPEN1:CALL UNLOCK7SEG
      MOV STATE, 00H ; now the 7seg is unlocked so change the state
      MOV ATTEMPTS, 0H ; initialize the number of wrong attempts to 0
      JMP STOP1
      
FAIL1: ;The tmp doesn not equal to the password so check the master code
      ; compare the value of TMP with MASTER
      MOV CL, 4
      LEA BX, TMP
      LEA SI, MASTER
  L7: MOV CH,BYTE PTR[BX]
      CMP CH,BYTE PTR[SI]
      JNE FAIL2; if does not match
      ;else move to next element 
      INC BX
      INC SI
      DEC CL
      CMP CL,0H
      JNZ L7
      ;the passwords match 
      JMP OPEN1
      ;
FAIL2:CALL ERROR
      ;; fetch the total number of wrong ATTEMPTS of password
      MOV SI, ATTEMPTS			
      INC SI 	      ;include this ATTEMPT in the total number of ATTEMPTS
      MOV ATTEMPTS, SI
      CALL WAIT_A_LITTLE
      CALL LOCK7SEG
      

STOP1: RET
CHECK_PASSWORD ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Function to check if the password is correct
CHECK_MASTER PROC NEAR

      ; compare the value of TMP with MASTER
      MOV CL, 4
      LEA BX, TMP
      LEA SI, MASTER
  L6: MOV CH,BYTE PTR[BX]
      CMP CH,BYTE PTR[SI]
      JNE FAIL3; if does not match
      ;else move to next element 
      INC BX
      INC SI
      DEC CL
      CMP CL,0H
      JNZ L6
      ;The passwords match
      CALL UNLOCK7SEG
      MOV STATE, 00H ; now the 7seg is unlocked so change the state
      MOV ATTEMPTS, 0H ; initialize the number of wrong attempts to 0
      JMP STOP2
      ;The password is wrong
FAIL3: CALL ERROR
       ;; fetch the total number of wrong ATTEMPTS of password
       MOV SI, ATTEMPTS			
       INC SI 	      ;include this ATTEMPT in the total number of ATTEMPTS
       MOV ATTEMPTS, SI
       CALL WAIT_A_LITTLE
       CALL LOCK7SEG

STOP2: RET
CHECK_MASTER ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Function to read a value from the keypad
READ PROC NEAR	
	   MOV DX,00H			; DX is used to select the column
	   MOV CL, 3	                ; because we will loop through the 3 columns
	   MOV BL, 08H	                ; BL 00001000 at the begining
   SUTUN:  SHR BL, 1	                ; We shift the 1 to select the next column (first case starting from first column 0100)
						   
	   MOV AL, BL
	   OUT 0AAH, AL	                ; We activate the column by sneding the value of BL to PORTB
	   IN AL, 0ACH	                ; Reading from Port C the value of the line selected
	   AND AL, 0FH	                ; we use masking with 0FH to clear the value of PortCH and preserve PortCL					
	   CMP AL, 00H	                ; check if the button was pressed or not
					 ;since the Port C is initialised by 0, if no button is pressed it will still be 0 
	   JE DEVAM1	                ; no button is pressed
	   PUSH AX		        ; else, a button is pressed so save the value the Port C to the stack
	   
   PRESSED:	
	   IN AL, 0ACH			; Reading from Port C the value of the line selected
	   AND AL, 0FH			; we use masking with 0FH to clear the value of PortCH and preserve PortCL	
	   CMP AL, 00H			; check if the button is still pressed or not
	   JNE PRESSED	                ; if it is still pressed keep waiting till it is released
	   
	   
	   POP AX			; take again the value of PORT C = the selected line
	   MOV DH, AL	                ; move the value of the selected line to DH to search for its index later
	   ; Now we extract the indices of the button pressed
	   ; Start by finding the column index
	   MOV CH, CL
	   DEC CH
	   MOV AL, 4
	   MUL CH		                 ; AX<-aktif olan sütunun ilk tusu bastan 
				                ; kaçinci sirada
	   
	   ; Finding the line index
 	   MOV DL, 0
   DEVAM3: SHR DH,1		       ; Searching for the location of the 1 stored from the line value
	   CMP DH, 00H		       ; When DH=0, DL stores the number of the line 0-> A, 1-> B , 2-> C, 3-> D
	   JE DEVAM2	               ; We found the line index
	   INC DL
	   JMP DEVAM3
	   
	
   DEVAM2: ADD AX, DX	               ; AH= column number and AL = line number
	   MOV SI, AX
	   
	   CMP SI,3H	;index of # is 3
	   JE Kare 	; the button pressed is #
	   MOV Hash, 0H	; the button pressed is not #
	   jmp Devam4

	  
Kare:	   MOV Hash, 1H 
Devam4:	   MOV IND, SI
	   MOV EMPTY,1H
	   JMP STOP1
	   
   DEVAM1: LOOP SUTUN	                ; listen at the next column  
	   CALL WAIT_A_LITTLE
   STOP1:  RET
READ ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_A_LITTLE PROC NEAR

;Remember to save previous values
;Looping to spend sometime

MOV CL, 0FFH
LOOP1: LOOP LOOP1

MOV CL, 0FFH
LOOP2: LOOP LOOP2

MOV CL, 0FFH
LOOP3: LOOP LOOP3

MOV CL, 0FFH
LOOP4: LOOP LOOP4
RET
WAIT_A_LITTLE ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE    ENDS
        END START